<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Clojure Scripting - ImageJ</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Clojure_Scripting","wgTitle":"Clojure Scripting","wgCurRevisionId":41219,"wgRevisionId":41219,"wgArticleId":7,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Scripting"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Clojure_Scripting","wgRelevantArticleId":7,"wgRequestId":"31df0235dae4b20e247300c2","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgPreferredVariant":"en","fancytree_path":"/extensions/TreeAndMenu/fancytree"});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user.cssprefs":"ready","user":"ready","user.options":"loading","user.tokens":"loading","ext.math.styles":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","skins.erudite":"ready"});mw.loader.implement("user.options@0j3lz3q",function($,jQuery,require,module){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens@1ku9xth",function ( $, jQuery, require, module ) {
mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});/*@nomin*/;

});mw.loader.load(["mediawiki.page.startup"]);});</script>
<link rel="stylesheet" href="erudite5.css"/>
<link rel="stylesheet" href="extensions/TreeAndMenu/fancytree/fancytree.css"/><link rel="stylesheet" href="extensions/TreeAndMenu/suckerfish/suckerfish.css"/>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="erudite15.css"/>
<meta name="generator" content="MediaWiki 1.28.0"/>
<meta name="description" content="Clojure is a dialect of the Lisp programming language. Clojure is a general-purpose programming language with an emphasis on functional programming."/>
<link rel="shortcut icon" href="skins/ij2.ico"/>

<script type="text/javascript" src="extensions/SyntaxHighlighter/syntaxhighlighter/scripts/shCore.js"></script>
<script type="text/javascript" src="extensions/SyntaxHighlighter/syntaxhighlighter/scripts/shBrushClojure.js"></script>
<script type="text/javascript" src="extensions/SyntaxHighlighter/syntaxhighlighter/scripts/shBrushBash.js"></script>
<script type="text/javascript">
SyntaxHighlighter.all();
</script>
<link rel="stylesheet" type="text/css" media="screen" href="extensions/SyntaxHighlighter/syntaxhighlighter/styles/shCoreMinit.css" />

	<meta property="og:type" content="article"/>

	<meta property="og:site_name" content="ImageJ"/>

	<meta property="og:title" content="Clojure Scripting"/>

	<meta property="og:description" content="Clojure is a dialect of the Lisp programming language. Clojure is a general-purpose programming language with an emphasis on functional programming."/>


<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Clojure_Scripting rootpage-Clojure_Scripting skin-erudite action-view">
		<div id="top-wrap" role="banner">
			<h1><a href="Welcome" title="ImageJ" rel="home">ImageJ</a></h1>
			<div id="tagline">From ImageJ</div>

			<a id="menubutton" href="Command_Launcher_Clojure.html#menu">Menu</a>
			<div id="nav" role="navigation">
			<ul id='menu'>
<li id="menu-item-n-About"><a href="ImageJ">About</a></li>
<li id="menu-item-n-Downloads"><a href="Downloads">Downloads</a></li>
<li id="menu-item-n-Learn"><a href="Learn">Learn</a></li>
<li id="menu-item-n-Develop"><a href="Development">Develop</a></li>
<li id="menu-item-n-News"><a href="News">News</a></li>
<li id="menu-item-n-Events"><a href="Events">Events</a></li>
<li id="menu-item-n-Help"><a href="Help">Help</a></li>
</ul>
			</div>
		</div>

		<div id="mw-js-message"></div>
		
		<div id="main" role="main">

			<div id="bodyContent">
				<div style="font-size: large; border: 1px solid black; padding: 1em; margin-bottom: 1em; text-align: center; background-color: #fda;">
					This is a read-only version of imagej.net, available during the transition to the new website, which you can preview <a href="https://imagej.github.io/">here</a>.
					<br>Please direct any questions or issues to <a href="https://forum.image.sc/t/imagej-wiki-is-down/39672">this Image.sc Forum thread</a>.
					<br>Thank you for your patience as we improve the website!
				</div>

				<h1>Clojure Scripting</h1>
				
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table class="infobox" cellspacing="5" style="text-align: left; float: right; border: 1px solid #a0a0a0; font-size: 80%;">
<tr>
<th colspan="2" style="font-size: 130%;">  Learn
</th></tr>
<tr>
<td>
</td></tr>
<tr>
<td>
<table class="infobox mw-collapsible mw-collapsed" cellspacing="5" data-collapsetext="-" data-expandtext="+" style="width: 100%; text-align: left; border-top: 1px solid #336699; border-right: none; border-left: none; border-bottom: none;">
<tr>
<th>  Topics
</th></tr>


<tr>
<td>  <a href="Introduction" title="Introduction">Introduction</a>
</td></tr>
<tr>
<td>  <a href="Getting_Started" title="Getting Started">Getting Started</a>
</td></tr>
<tr>
<td>  <a href="User_Guides" title="User Guides">User Guides</a>
</td></tr>
<tr>
<td>  <a href="./Category:Tutorials" title="Category:Tutorials">Tutorials</a>
</td></tr>
<tr>
<td>  <a href="Tips_and_Tricks" title="Tips and Tricks">Tips and Tricks</a>
</td></tr>
<tr>
<td>  <a href="Presentations" title="Presentations">Presentations</a>
</td></tr>
<tr>
<td>  <a href="Plugins" title="Plugins">Plugins</a>
</td></tr></table>
</td></tr>
<tr>
<td>
<table class="infobox mw-collapsible mw-collapsed" cellspacing="5" data-collapsetext="-" data-expandtext="+" style="width: 100%; text-align: left; border-top: 1px solid #336699; border-right: none; border-left: none; border-bottom: none;">
<tr>
<th>  Techniques
</th></tr>


<tr>
<td>  <a href="./Category:Techniques" title="Category:Techniques">All Techniques</a>
</td></tr>
<tr>
<td>  <a href="Colocalization_Analysis" title="Colocalization Analysis"> Colocalization</a>
</td></tr>
<tr>
<td>  <a href="Deconvolution" title="Deconvolution">Deconvolution</a>
</td></tr>
<tr>
<td>  <a href="Registration" title="Registration">Registration</a>
</td></tr>
<tr>
<td>  <a href="Segmentation" title="Segmentation">Segmentation</a>
</td></tr>
<tr>
<td>  <a href="Image_Stitching" title="Image Stitching"> Stitching</a>
</td></tr>
<tr>
<td>  <a href="Tracking" title="Tracking">Tracking</a>
</td></tr>
<tr>
<td>  <a href="Visualization" title="Visualization">Visualization</a>
</td></tr></table>
</td></tr>
<tr>
<td>
<table class="infobox mw-collapsible mw-collapsed" cellspacing="5" data-collapsetext="-" data-expandtext="+" style="width: 100%; text-align: left; border-top: 1px solid #336699; border-right: none; border-left: none; border-bottom: none;">
<tr>
<th>  Scripting
</th></tr>


<tr>
<td>  <a href="Scripting" title="Scripting">Overview</a>
</td></tr>
<tr>
<td>  <a href="User_input" title="User input">User input</a>
</td></tr>
<tr>
<td>  <a href="Scripting_basics" title="Scripting basics">Basics of script writing</a>
</td></tr>
<tr>
<td>  <a href="How_to_use_the_Javadoc" title="How to use the Javadoc">How to use the Javadoc</a>
</td></tr>
<tr>
<td>  <a href="Batch_Processing" title="Batch Processing">Batch processing</a>
</td></tr>
<tr>
<td>  <a href="Using_the_Script_Editor" title="Using the Script Editor">Script Editor</a>
</td></tr>
<tr>
<td>  <a href="Script_Editor_Auto_Import" title="Script Editor Auto Import">Auto Imports</a>
</td></tr>
<tr>
<td>  <a href="Script_Templates" title="Script Templates">Templates</a>
</td></tr>
<tr>
<td>  <a href="Scripting_Headless" title="Scripting Headless">Running headlessly</a>
</td></tr>
<tr>
<td>  <a href="Scripting_comparisons" title="Scripting comparisons">Comparisons</a>
</td></tr>
<tr>
<td>  <a href="Scripting_toolbox" title="Scripting toolbox">Toolbox</a>
</td></tr>
<tr>
<td>  <a href="Multithreaded_Image_Processing_in_Clojure" title="Multithreaded Image Processing in Clojure">Multithreading in Clojure</a>
</td></tr>
<tr>
<td>  <a href="Multithreaded_Image_Processing_in_JavaScript" title="Multithreaded Image Processing in JavaScript">Multithreading in JavaScript</a>
</td></tr>
<tr>
<td>  <a href="Chess" title="Chess">Chess</a> in Jython
</td></tr></table>
</td></tr>
<tr>
<td>
<table class="infobox mw-collapsible" cellspacing="5" data-collapsetext="-" data-expandtext="+" style="width: 100%; text-align: left; border-top: 1px solid #336699; border-right: none; border-left: none; border-bottom: none;">
<tr>
<th>  Languages
</th></tr>


<tr>
<td>  <a href="BeanShell_Scripting" title="BeanShell Scripting">BeanShell</a>
</td></tr>
<tr>
<td>  <a href="Groovy_Scripting" title="Groovy Scripting">Groovy</a>
</td></tr>
<tr>
<td>  <a href="Introduction_into_Macro_Programming" title="Introduction into Macro Programming">ImageJ Macro</a>
</td></tr>
<tr>
<td>  <a href="JavaScript_Scripting" title="JavaScript Scripting">JavaScript</a>
</td></tr>
<tr>
<td>  <strong class="selflink">Lisp (Clojure)</strong>
</td></tr>
<tr>
<td>  <a href="MATLAB_Scripting" title="MATLAB Scripting">MATLAB</a>
</td></tr>
<tr>
<td>  <a href="Jython_Scripting" title="Jython Scripting">Python (Jython)</a>
</td></tr>
<tr>
<td>  <a href="Renjin_Scripting" title="Renjin Scripting">R (Renjin)</a>
</td></tr>
<tr>
<td>  <a href="JRuby_Scripting" title="JRuby Scripting">Ruby (JRuby)</a>
</td></tr>
<tr>
<td>  <a href="Scala_Scripting" title="Scala Scripting">Scala</a>
</td></tr></table>
</td></tr></table>
<p><a href="http://en.wikipedia.org/wiki/Clojure" class="extiw" title="wikipedia:Clojure">Clojure</a> is a dialect of the <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)" class="extiw" title="wikipedia:Lisp (programming language)">Lisp programming language</a>. Clojure is a general-purpose programming language with an emphasis on functional programming.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Command_Launcher_Clojure.html#Clojure_tutorial_for_ImageJ"><span class="tocnumber">1</span> <span class="toctext">Clojure tutorial for ImageJ</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="Command_Launcher_Clojure.html#Using_Clojure_inside_Fiji"><span class="tocnumber">1.1</span> <span class="toctext">Using Clojure inside Fiji</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="Command_Launcher_Clojure.html#Convenient_Clojure_in_Fiji_with_Funimage"><span class="tocnumber">1.1.1</span> <span class="toctext">Convenient Clojure in Fiji with Funimage</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="Command_Launcher_Clojure.html#Running_Clojure_files_from_the_command_line"><span class="tocnumber">1.1.2</span> <span class="toctext">Running Clojure files from the command line</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="Command_Launcher_Clojure.html#Getting_a_REPL_without_the_usual_ImageJ_GUI"><span class="tocnumber">1.1.3</span> <span class="toctext">Getting a REPL without the usual ImageJ GUI</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="Command_Launcher_Clojure.html#Debugging_with_the_Java_Debugger"><span class="tocnumber">1.1.4</span> <span class="toctext">Debugging with the Java Debugger</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-7"><a href="Command_Launcher_Clojure.html#Language_basics"><span class="tocnumber">1.2</span> <span class="toctext">Language basics</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="Command_Launcher_Clojure.html#Importing_classes"><span class="tocnumber">1.2.1</span> <span class="toctext">Importing classes</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="Command_Launcher_Clojure.html#Calling_methods_and_variables_on_a_java_object"><span class="tocnumber">1.3</span> <span class="toctext">Calling methods and variables on a java object</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="./Command_Launcher_Clojure.html#Calling_static_fields_and_methods:_namespace_syntax"><span class="tocnumber">1.4</span> <span class="toctext">Calling static fields and methods: namespace syntax</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="./Command_Launcher_Clojure.html#Defining_variables:_obtaining_the_current_image"><span class="tocnumber">1.5</span> <span class="toctext">Defining variables: obtaining the current image</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="./Command_Launcher_Clojure.html#Creating_objects:_invoking_constructors"><span class="tocnumber">1.6</span> <span class="toctext">Creating objects: invoking constructors</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="Command_Launcher_Clojure.html#Defining_a_closure"><span class="tocnumber">1.7</span> <span class="toctext">Defining a closure</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="Command_Launcher_Clojure.html#Manipulating_images"><span class="tocnumber">1.8</span> <span class="toctext">Manipulating images</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="./Command_Launcher_Clojure.html#ImageJ_Image_internals:_ImagePlus.2C_ImageProcessor.2C_ImageStack"><span class="tocnumber">1.8.1</span> <span class="toctext">ImageJ Image internals: ImagePlus, ImageProcessor, ImageStack</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="Command_Launcher_Clojure.html#Conventions_in_naming_image_variables"><span class="tocnumber">1.8.2</span> <span class="toctext">Conventions in naming image variables</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="Command_Launcher_Clojure.html#Creating_a_new_image"><span class="tocnumber">1.8.3</span> <span class="toctext">Creating a new image</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="Command_Launcher_Clojure.html#Creating_an_image_of_the_same_type_of_an_existing_one"><span class="tocnumber">1.8.4</span> <span class="toctext">Creating an image of the same type of an existing one</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="Command_Launcher_Clojure.html#Resizing_an_image"><span class="tocnumber">1.8.5</span> <span class="toctext">Resizing an image</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="Command_Launcher_Clojure.html#Resizing_an_ImageStack"><span class="tocnumber">1.8.6</span> <span class="toctext">Resizing an ImageStack</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="Command_Launcher_Clojure.html#Resizing_an_image_or_ImageStack_using_ROIs"><span class="tocnumber">1.8.7</span> <span class="toctext">Resizing an image or ImageStack using ROIs</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-22"><a href="Command_Launcher_Clojure.html#Manipulate_images_using_ImgLib"><span class="tocnumber">1.9</span> <span class="toctext">Manipulate images using ImgLib</span></a>
<ul>
<li class="toclevel-3 tocsection-23"><a href="Command_Launcher_Clojure.html#Multiply_each_pixel_by_0.5"><span class="tocnumber">1.9.1</span> <span class="toctext">Multiply each pixel by 0.5</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="Command_Launcher_Clojure.html#Normalize_an_image"><span class="tocnumber">1.9.2</span> <span class="toctext">Normalize an image</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-25"><a href="Command_Launcher_Clojure.html#Looping_an_array_of_pixels"><span class="tocnumber">1.10</span> <span class="toctext">Looping an array of pixels</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="Command_Launcher_Clojure.html#Executing_commands_from_the_menus"><span class="tocnumber">1.11</span> <span class="toctext">Executing commands from the menus</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="Command_Launcher_Clojure.html#Creating_and_using_Clojure_scripts_as_ImageJ_plugins"><span class="tocnumber">1.12</span> <span class="toctext">Creating and using Clojure scripts as ImageJ plugins</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="Command_Launcher_Clojure.html#Using_java_beans_for_quick_and_convenient_access_to_an_object.27s_fields"><span class="tocnumber">1.13</span> <span class="toctext">Using java beans for quick and convenient access to an object's fields</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="Command_Launcher_Clojure.html#Examples"><span class="tocnumber">2</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-29"><a href="./Command_Launcher_Clojure.html#Fixing_overexposed_images:_setting_a_pixel_value_to_a_desirable_one_for_all_overexposed_pixels"><span class="tocnumber">2.1</span> <span class="toctext">Fixing overexposed images: setting a pixel value to a desirable one for all overexposed pixels</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="Command_Launcher_Clojure.html#Creating_a_script_for_ImageJ"><span class="tocnumber">2.2</span> <span class="toctext">Creating a script for ImageJ</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="Command_Launcher_Clojure.html#Example_Clojure_plugins_included_in_Fiji"><span class="tocnumber">2.3</span> <span class="toctext">Example Clojure plugins included in Fiji</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="Command_Launcher_Clojure.html#Appendix"><span class="tocnumber">3</span> <span class="toctext">Appendix</span></a>
<ul>
<li class="toclevel-2 tocsection-32"><a href="Command_Launcher_Clojure.html#Defining_the_output_stream"><span class="tocnumber">3.1</span> <span class="toctext">Defining the output stream</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="Command_Launcher_Clojure.html#Destructuring"><span class="tocnumber">3.2</span> <span class="toctext">Destructuring</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="Command_Launcher_Clojure.html#Namespaces"><span class="tocnumber">3.3</span> <span class="toctext">Namespaces</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="Command_Launcher_Clojure.html#Forget.2FRemove_all_variables_from_a_namespace"><span class="tocnumber">3.4</span> <span class="toctext">Forget/Remove all variables from a namespace</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="Command_Launcher_Clojure.html#JVM_arguments"><span class="tocnumber">3.5</span> <span class="toctext">JVM arguments</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="Command_Launcher_Clojure.html#Reflection"><span class="tocnumber">3.6</span> <span class="toctext">Reflection</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="Command_Launcher_Clojure.html#Lambda_functions"><span class="tocnumber">3.7</span> <span class="toctext">Lambda functions</span></a>
<ul>
<li class="toclevel-3 tocsection-39"><a href="Command_Launcher_Clojure.html#Declaration"><span class="tocnumber">3.7.1</span> <span class="toctext">Declaration</span></a></li>
<li class="toclevel-3 tocsection-40"><a href="Command_Launcher_Clojure.html#Mapping_a_function_to_all_elements_in_a_list"><span class="tocnumber">3.7.2</span> <span class="toctext">Mapping a function to all elements in a list</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-41"><a href="Command_Launcher_Clojure.html#Built-in_documentation"><span class="tocnumber">3.8</span> <span class="toctext">Built-in documentation</span></a>
<ul>
<li class="toclevel-3 tocsection-42"><a href="Command_Launcher_Clojure.html#Defining_documentation_for_your_own_functions"><span class="tocnumber">3.8.1</span> <span class="toctext">Defining documentation for your own functions</span></a></li>
<li class="toclevel-3 tocsection-43"><a href="Command_Launcher_Clojure.html#Defining_documentation_for_a_variable"><span class="tocnumber">3.8.2</span> <span class="toctext">Defining documentation for a variable</span></a></li>
<li class="toclevel-3 tocsection-44"><a href="Command_Launcher_Clojure.html#Adding_a_test_function_to_a_variable"><span class="tocnumber">3.8.3</span> <span class="toctext">Adding a test function to a variable</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-45"><a href="./Command_Launcher_Clojure.html#A_fibonacci_sequence:_lazy_and_infinite_sequences"><span class="tocnumber">3.9</span> <span class="toctext">A fibonacci sequence: lazy and infinite sequences</span></a>
<ul>
<li class="toclevel-3 tocsection-46"><a href="Command_Launcher_Clojure.html#Printing_lazy_sequences_to_the_REPL"><span class="tocnumber">3.9.1</span> <span class="toctext">Printing lazy sequences to the REPL</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-47"><a href="Command_Launcher_Clojure.html#Creating_shallow_and_deep_sequences_from_java_arrays"><span class="tocnumber">3.10</span> <span class="toctext">Creating shallow and deep sequences from java arrays</span></a></li>
<li class="toclevel-2 tocsection-48"><a href="Command_Launcher_Clojure.html#Generating_java_classes_in_.class_files_from_clojure_code"><span class="tocnumber">3.11</span> <span class="toctext">Generating java classes in .class files from clojure code</span></a></li>
<li class="toclevel-2 tocsection-49"><a href="Command_Launcher_Clojure.html#References.2C_concurrency.2C_transactions_and_synchronization"><span class="tocnumber">3.12</span> <span class="toctext">References, concurrency, transactions and synchronization</span></a></li>
<li class="toclevel-2 tocsection-50"><a href="Command_Launcher_Clojure.html#Using_try.2Fcatch.2Ffinally_and_throwing_Exceptions"><span class="tocnumber">3.13</span> <span class="toctext">Using try/catch/finally and throwing Exceptions</span></a></li>
<li class="toclevel-2 tocsection-51"><a href="Command_Launcher_Clojure.html#Executing_a_command_in_a_shell_and_capturing_its_output"><span class="tocnumber">3.14</span> <span class="toctext">Executing a command in a shell and capturing its output</span></a></li>
<li class="toclevel-2 tocsection-52"><a href="Command_Launcher_Clojure.html#Creating_a_derivative_of_a_function"><span class="tocnumber">3.15</span> <span class="toctext">Creating a derivative of a function</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="Command_Launcher_Clojure.html#Pretty_printing_a_primitive_array"><span class="tocnumber">3.16</span> <span class="toctext">Pretty printing a primitive array</span></a></li>
<li class="toclevel-2 tocsection-54"><a href="Command_Launcher_Clojure.html#Loading_an_image_file_into_a_byte_array"><span class="tocnumber">3.17</span> <span class="toctext">Loading an image file into a byte array</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Clojure_tutorial_for_ImageJ">Clojure tutorial for ImageJ</span></h1>
<p>Check out <a rel="nofollow" class="external text" href="http://clojure.org">clojure web site</a> and particularly the chapter on <a rel="nofollow" class="external text" href="http://clojure.org/java_interop">Java interoperability</a>.</p>
<p>Clojure is <b>not</b> a scripting language: Clojure compiles directly to JVM bytecode, and thus runs at native speed. Thus one must think of Clojure as a true alternative to Java the language, but much more expressive, flexible and powerful.</p>
<p>See also:</p>
<ul><li><a rel="nofollow" class="external text" href="http://en.wikibooks.org/wiki/Clojure_Programming/Examples/Cookbook">Clojure Cookbook</a>.</li>
<li><a rel="nofollow" class="external text" href="http://clojure.org/api">The Clojure API</a> (listing of all available functions, with explanations).</li>
<li><a rel="nofollow" class="external text" href="http://clojure.org/cheatsheet">Clojure cheat sheet</a>: a summary of all the essentials.</li></ul>
<h2><span class="mw-headline" id="Using_Clojure_inside_Fiji">Using Clojure inside Fiji</span></h2>
<p>Go to <span><em><span style="border-bottom:1px dotted #ccc;">Plugins</span>&#160;&#8250; <span style="border-bottom:1px dotted #ccc;">Scripting</span>&#160;&#8250; <span style="border-bottom:1px dotted #ccc;">Clojure Interpreter</span></em></span>. The prompt accepts any clojure code. See also Fiji's <a href="Script_Editor" class="mw-redirect" title="Script Editor">Script Editor</a>.
</p><p>See <a href="Scripting_Help" class="mw-redirect" title="Scripting Help">Scripting Help</a> for details on keybindings and how to use the interpreter. <kbd class="keyboard-key nowrap" style="border: 1px solid #aaa; -moz-border-radius: 0.2em; -webkit-border-radius: 0.2em; border-radius: 0.2em; -moz-box-shadow: 0.1em 0.2em 0.2em #ddd; -webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; box-shadow: 0.1em 0.2em 0.2em #ddd; background-color: #f9f9f9; background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: linear-gradient(&#91;&#91;:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); padding: 0.1em 0.3em; font-family: inherit; font-size: 0.85em;"><span class="Unicode">^</span> Ctrl</kbd>+<kbd class="keyboard-key nowrap" style="border: 1px solid #aaa; -moz-border-radius: 0.2em; -webkit-border-radius: 0.2em; border-radius: 0.2em; -moz-box-shadow: 0.1em 0.2em 0.2em #ddd; -webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; box-shadow: 0.1em 0.2em 0.2em #ddd; background-color: #f9f9f9; background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: linear-gradient(&#91;&#91;:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); padding: 0.1em 0.3em; font-family: inherit; font-size: 0.85em;">)</kbd> will add all necessary ending parenthesis.
</p><p>A minimal, complete clojure example:
</p>
<pre class="brush:clojure">
(import '(ij IJ))
(def gold (IJ/openImage "https://imagej.net/images/AuPbSn40.jpg"))
(.show gold)
</pre>
<p>To create scripts, just save them as .clj text files (with an underscore in the name) in any folder or subfolder of Fiji's plugins folder, and run <span><em><span style="border-bottom:1px dotted #ccc;">Plugins</span>&#160;&#8250; <span style="border-bottom:1px dotted #ccc;">Scripting</span>&#160;&#8250; <span style="border-bottom:1px dotted #ccc;">Refresh Clojure Scripts</span></em></span> to update the menus (it's done automatically at start up as well).
</p><p>To edit a script, just edit and save it with your favorite text editor.
</p><p>To execute a script, do any of:
</p>
<ul><li> Select it from the plugins menus.</li>
<li> Type 'l' (L), start typing its name, push the down arrow and then return to execute it.</li>
<li> If it was the last executed command, just type <kbd class="keyboard-key nowrap" style="border: 1px solid #aaa; -moz-border-radius: 0.2em; -webkit-border-radius: 0.2em; border-radius: 0.2em; -moz-box-shadow: 0.1em 0.2em 0.2em #ddd; -webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; box-shadow: 0.1em 0.2em 0.2em #ddd; background-color: #f9f9f9; background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: linear-gradient(&#91;&#91;:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); padding: 0.1em 0.3em; font-family: inherit; font-size: 0.85em;"><span class="Unicode">â‡§</span> Shift</kbd>+<kbd class="keyboard-key nowrap" style="border: 1px solid #aaa; -moz-border-radius: 0.2em; -webkit-border-radius: 0.2em; border-radius: 0.2em; -moz-box-shadow: 0.1em 0.2em 0.2em #ddd; -webkit-box-shadow: 0.1em 0.2em 0.2em #ddd; box-shadow: 0.1em 0.2em 0.2em #ddd; background-color: #f9f9f9; background-image: -moz-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -o-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: -webkit-linear-gradient(top, #eee, #f9f9f9, #eee); background-image: linear-gradient(&#91;&#91;:Template:Linear-gradient/legacy]], #eee, #f9f9f9, #eee); padding: 0.1em 0.3em; font-family: inherit; font-size: 0.85em;">R</kbd> (shortcut to "Process - Repeat Command").</li></ul>
<p>The script is <b>always</b> read directly from the source file, so no updating of menus is needed (unless its file name changes).
</p>
<h3><span class="mw-headline" id="Convenient_Clojure_in_Fiji_with_Funimage">Convenient Clojure in Fiji with Funimage</span></h3>
<ul><li><a rel="nofollow" class="external text" href="https://github.com/funimage/funimage/">Funimage</a> provides a library for convenient Clojure coding within Fiji. Alleviating much of the need for type-hinting, and some of the burdens involved in handling more complicated data structures, such as those from ImgLib2.</li></ul>
<p>See the <a rel="nofollow" class="external text" href="https://imagej.github.io/list-of-update-sites/">list of update sites</a> for information on setting up the Funimage update site.
</p>
<h3><span class="mw-headline" id="Running_Clojure_files_from_the_command_line">Running Clojure files from the command line</span></h3>
<p>Fiji can execute any clojure file directly:
</p>
<pre class="brush:bash">
./fiji plugins/Examples/blend_two_images.clj
</pre>
<p>The file will run with the full classpath as set by fiji, which includes all jars in fiji/jars and fiji/plugins/ folders, among others.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Getting_a_REPL_without_the_usual_ImageJ_GUI">Getting a REPL without the usual ImageJ GUI</span></h3>
<p>The simplest is:
</p>
<pre class="brush:bash">
./fiji --clojure
</pre>
<p>... which you may enrich with memory settings, incremental garbage collection (works great for multicore CPUs), the enhanced JIT (server flag), and a debugger agent (and any other JVM flag):
</p>
<pre class="brush:bash">
./fiji -Xmx2000m -Xincgc -server -agentlib:jdwp=transport=dt_socket,address=8010,server=y,suspend=n --clojure --
</pre>
<p>Above, <b>notice the ending double dash --</b> which separates Fiji/JVM options from ImageJ options (in this case, none).
</p><p>For a nicer Repl, you may want to run the clojure.lang.Repl via the jline.ConsoleRunner, which gives you up and down arrow navigation, etc:
</p>
<pre class="brush:bash">
./fiji -Xmx2000m -Xincgc -server -agentlib:jdwp=transport=dt_socket,address=8010,server=y,suspend=n \
         --main-class jline.ConsoleRunner -- clojure.lang.Repl
</pre>
<p>Note that we put the double-dash between <i>jline.ConsoleRunner</i> (the main class to launch) and <i>clojure.lang.Repl</i> (its arguments).
</p><p>If no JVM arguments were specified, there's no need for the double dash:
</p>
<pre class="brush:bash">
./fiji --main-class jline.ConsoleRunner clojure.lang.Repl
</pre>
<p>Just make sure to have the jline.jar in your classpath (or drop it into fiji/jars folder).
</p>
<h3><span class="mw-headline" id="Debugging_with_the_Java_Debugger">Debugging with the Java Debugger</span></h3>
<p>If you have launched fiji with an agentlib, you may then connect to it via the <i>jdb</i>:
</p><p>First launch fiji with the agentlib:
</p>
<pre class="brush:bash">
./fiji -agentlib:jdwp=transport=dt_socket,address=8010,server=y,suspend=n --
</pre>
<p>Then connect, at the same port address:
</p>
<pre class="brush:bash">
cd fiji/java/linux/jdk1.6.0_12/bin/
./jdb -attach 8010
</pre>
<p>Which gives you a jdb prompt after printing:
</p>
<pre> Set uncaught java.lang.Throwable
 Set deferred uncaught java.lang.Throwable
 Initializing jdb ...
 &gt;
</pre>
<p>Now you may query about threads:
</p>
<pre> &gt; threads
 Group system:
   (java.lang.ref.Reference$ReferenceHandler)0x72b Reference Handler cond. waiting
   (java.lang.ref.Finalizer$FinalizerThread)0x72c  Finalizer         cond. waiting
   (java.lang.Thread)0x72d                         Signal Dispatcher running
</pre>
<p>And suspend all to see the stack trace of each thread:
</p>
<pre> &gt; suspend
 &gt; where 0x72d
 [1] java.io.FileInputStream.read (native method)
 [2] jline.Terminal.readCharacter (Terminal.java:99)
 [3] jline.UnixTerminal.readVirtualKey (UnixTerminal.java:128)
 [4] jline.ConsoleReader.readVirtualKey (ConsoleReader.java:1,450)
 [5] jline.ConsoleReader.readBinding (ConsoleReader.java:651)
 [6] jline.ConsoleReader.readLine (ConsoleReader.java:492)
 [7] jline.ConsoleReader.readLine (ConsoleReader.java:446)
 [8] jline.ConsoleReader.readLine (ConsoleReader.java:298)
 [9] jline.ConsoleReaderInputStream$ConsoleLineInputStream.read (ConsoleReaderInputStream.java:92)
 ...
</pre>
<p><br />
There are perhaps more convenient setups built into Eclipse, IntelliJ, NetBeans and other IDEs that support Clojure via plugins, but the jdb gives you what you want very quickly.
</p><p>Within the jdb prompt, type "help".
</p>
<h2><span class="mw-headline" id="Language_basics">Language basics</span></h2>
<ul><li> A ';' defines the start of a comment, just like '//' does in Java.</li>
<li> A function definition declares parameters within [].</li>
<li> Local variables are declared with <i>let</i>, and global variables with <i>def</i>.</li>
<li> Functions are defined with <i>defn</i>, and are visible globally. Hence a function declared within a <i>let</i> statement has access to variables declared in it. This method enables closures.</li></ul>
<h3><span class="mw-headline" id="Importing_classes">Importing classes</span></h3>
<p>To reference Java classes from Clojure you will need to import them.
</p>
<div style="overflow:hidden"><table class="metadata plainlinks ambox ambox-content">
<tr>
<td class="ambox-image">
<p><a href="./File:Important-sign.png" class="image"><img alt="Important-sign.png" src="_images/f/f0/Important-sign.png" width="40" height="40" /></a>
</p>
</td>
<td> Unlike <a href="ImageJ_1.x" class="mw-redirect" title="ImageJ 1.x">ImageJ 1.x</a>, <a href="ImageJ2" title="ImageJ2">ImageJ2</a> (and therefore <a href="Fiji" title="Fiji">Fiji</a>) does not automatically import any classes. Consequently, scripts written for <a href="ImageJ_1.x" class="mw-redirect" title="ImageJ 1.x">ImageJ 1.x</a> will not run in <a href="ImageJ2" title="ImageJ2">ImageJ2</a> without adding the proper imports.
The rationale is that the auto-import feature is not safe. What if two classes of the same name live in two different packages? Or if a new class is introduced that makes formerly unique names ambiguous? All of a sudden, all of the scripts that reference the original class no longer work. In short: auto-imports are dangerously imprecise. </td>


</tr>
</table></div>
<p><br />
You can specify imports in Clojure in a few ways:
</p>
<pre class="brush:clojure">
; A single import.
(import java.util.Date)

; Use it!
(def *now* (Date.))
(str *now*)

; Multiple imports at once.
(import '(java.util Date Calendar)
        '(java.net URI ServerSocket)
        java.sql.DriverManager)

; Import multiple classes in a namespace.
(ns foo.bar
  (:import (java.util Date
                      Calendar)
           (java.util.logging Logger
                              Level)))
</pre>
<h2><span class="mw-headline" id="Calling_methods_and_variables_on_a_java_object">Calling methods and variables on a java object</span></h2>
<p>There are two ways, the second syntactic sugar of the first. Below, <b>imp</b> is a pointer to an ImagePlus:</p>
<pre class="brush:clojure">
; java-ish way:
(. imp (getProcessor))

; shorter java-ish way:
(. imp getProcessor)

; lisp-ish way:
(.getProcessor imp)
</pre>
<p>To call a method on an object returned by a method call, there is a simplified way:</p>
<pre class="brush:clojure">
; double way:
(. (. imp (getProcessor)) (getPixels))

; simplified double way:
(.. imp (getProcessor) (getPixels))

; super simplified (less parenthesis than java!)
(.. imp getProcessor getPixels)

; or lisp-ish way:
(.getPixels (.getProcessor imp))
</pre>
<p>Any number of concatenated method calls, both for static methods or for instances:</p>
<pre class="brush:clojure">
; Concatenated call to static and instance methods
(.. WindowManager getCurrentImage getProcessor getPixels)
</pre>
<p>To call a variable or 'field', just do it like a method call but without the parentheses:</p>
<pre class="brush:clojure">
(. imp changes)
</pre>
<p>or more lisp-ish:
</p>
<pre class="brush:clojure">
(.changes imp)
</pre>
<p>To enhance readability, use <i>import</i> when appropriate. Imports remain visible throughout the current namespace:</p>
<pre class="brush:clojure">
(import '(java.awt Color Rectangle)
        '(ij.plugin.filter PlugInFilter))

(new Rectangle 0 0 500 500)
; It's the same as:
(Rectangle. 0 0 500 500)

; A static field, call like a namespace:
PlugInFilter/DOES_ALL
</pre>
<p>Choose whatever matches your mental schemes best.</p>
<p><br />
</p>
<h2><span class="mw-headline" id="Calling_static_fields_and_methods:_namespace_syntax">Calling static fields and methods: namespace syntax</span></h2>
<p>To call a <b>static</b> field or method, use namespace syntax:</p>
<pre class="brush:clojure">
(println "does all: " ij.plugin.filter.PlugInFilter/DOES_ALL)

(ij.IJ/log "Some logged text")
</pre>
<p>Above, notice how a class name is used instead of a pointer to call static fields and methods. Static fields and methods are just variables and functions that exist within the namespace of the class in which they are declared. Hence Clojure's namespace syntax makes way more sense than java code, that doesn't do such distinction and allows for loads of confusion (java allows invoking static methods and fields using a pointer to an instance of the class in which such static methods and fields are declared).</p>
<p><br />
</p>
<h2><span class="mw-headline" id="Defining_variables:_obtaining_the_current_image">Defining variables: obtaining the current image</span></h2>
<p>As a local variable <b>imp</b> declared within a <i>let</i> statement:
</p>
<pre class="brush:clojure">
(let [imp (ij.WindowManager/getCurrentImage)]
   &#160;; print its name
    (println (.getTitle imp)))

; Variable imp NOT visible from outside let statement:
(println (.getTitle imp))
---&gt; ERROR
</pre>
<p>As a general variable visible from the entire namespace:</p>
<pre class="brush:clojure">
(def *imp* (ij.WindowManager/getCurrentImage))

(println (.getTitle *imp*))
</pre>
<p>By convention, in lisp global variables are written with asterisks in the name.</p>
<p><br />
</p>
<p>A <i>let</i> statement lets you declare any number of paired variable name / values, even referring to each other in sequence:</p>
<pre class="brush:clojure">
(let [imp (ij.WindowManager/getCurrentImage)
      ip (.getProcessor imp)
      pix (.getPixels ip)
      pix2 (.getPixels (.getProcessor imp))]
   &#160;; do some processing ...
    (println (str "number of pixels: " (count pix))))
</pre>
<p>Any number of <i>let</i> statements may be nested together:</p>
<pre class="brush:clojure">
(let [imp (ij.WindowManager/getCurrentImage)]
   &#160;; do whatever processing here
    (let [ip (.getProcessor imp]
       &#160;; print first pixel
	(println (str (.getPixel ip 0 0))))))
</pre>
<p><br />
</p>
<h2><span class="mw-headline" id="Creating_objects:_invoking_constructors">Creating objects: invoking constructors</span></h2>
<p>A constructor is invoked by adding a dot '.' to the name of a class, followed by the arguments. Below, we create an ImageProcessor and then an ImagePlus with it, and finally we print the ImagePlus, which invokes toString() on it (like in java):
</p>
<pre class="brush:clojure">
(let [ip (ij.process.ByteProcessor. 400 400)
      imp (ij.ImagePlus. "my image" ip)]
  (println imp))
</pre>
<p>An alternative syntax is to use the java-like <i>new</i> keyword, but it's unnecessarily verbose:
</p>
<pre class="brush:clojure">
(let [ip (new ij.process.ByteProcessor 400 400)
      imp (new ij.ImagePlus "my image" ip)]
  (println imp))
</pre>
<p><br />
</p>
<h2><span class="mw-headline" id="Defining_a_closure">Defining a closure</span></h2>
<p>In the following a function is declared within the scope of the local variable <b>rand</b>, which contains an instance of java.util.Random. All calls to the function <i>rand-double</i> will use the same random number generator instance with seed 69997.</p>
<p>The <i>dotimes</i> loop will then print 10 different pseudo-random numbers. If the <b>rand</b> was a new Random with seed 69997 every time, all 10 numbers would be exactly the same.</p>
<p>You can think of a function inside a closure as a static function using a static variable (in Java), but it's more than that, since the function will be able to access parameters on the global namespace and also in any other local namespace in which the <i>let</i> is declared. For example, another <i>let</i>, or even another <i>defn</i>!</p>
<pre class="brush:clojure">
(let [rand (java.util.Random. 69997)]
    (defn rand-double []
        (.nextDouble rand)))

(dotimes [i 10]
    (println (rand-double)))
</pre>
<p>Above, note the dot '.' after Random, which indicates we are calling the constructor (with a single parameter 69997, the pseudorandom generator seed to be used). Alternatively, one may use the java-like syntax: (new java.util.Random 69997) -- note the absence of a dot now.</p>
<p><br />
</p>
<h2><span class="mw-headline" id="Manipulating_images">Manipulating images</span></h2>
<h3><span class="mw-headline" id="ImageJ_Image_internals:_ImagePlus.2C_ImageProcessor.2C_ImageStack">ImageJ Image internals: ImagePlus, ImageProcessor, ImageStack</span></h3>
<p>ImageJ has three basic objects:
</p>
<ul><li> The <b><a rel="nofollow" class="external text" href="developer/api/ij/ImagePlus.html">ImagePlus</a></b>, which wraps the ImageProcessor and contains properties and pointers to the ROI (region of interest) and the ImageWindow that may be displaying the image.</li>
<li> The <b><a rel="nofollow" class="external text" href="developer/api/ij/process/ImageProcessor.html">ImageProcessor</a></b>, which is an abstract class enabling the high-level manipulation of and access to pixels. Its subclasses each wraps a different kind of data type:
<ul><li> ByteProcessor - byte[]</li>
<li> ShortProcessor - short[]</li>
<li> FloatProcessor - float[]</li>
<li> ColorProcessor - int[] (byte-packed ARGB, but Alpha channel is ignored)</li></ul></li>
<li> The <b><a rel="nofollow" class="external text" href="developer/api/ij/ImageStack.html">ImageStack</a></b> which contains unfortunately not an array of ImageProcessor, but an Object[] containing an homogeneous list of equal length byte[], or float[], etc.</li></ul>
<p>For extensive documentation, see the <a rel="nofollow" class="external text" href="http://albert.rierol.net/imagej_programming_tutorials.html#ImageJ%20programming%20basics">Anatomy of an ImageJ image</a> ImageJ programming basics tutorial.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Conventions_in_naming_image_variables">Conventions in naming image variables</span></h3>
<p>By convention, variables are named:
</p>
<ul><li> <b>imp</b> to mean ImagePlus</li>
<li> <b>ip</b> to mean ImageProcessor</li>
<li> <b>stack</b> to mean ImageStack</li></ul>
<p><br />
</p>
<h3><span class="mw-headline" id="Creating_a_new_image">Creating a new image</span></h3>
<p>From scratch:
</p>
<pre class="brush:clojure">
(import '(ij ImagePlus)
        '(ij.process ByteProcessor))

(let [imp (ImagePlus. "A new image" (ByteProcessor. 400 400))]
  (.show imp))
</pre>
<p>From a file:
</p>
<pre class="brush:clojure">
(let [imp (IJ/openImage "/path/to/an/image.tif")]
  (.show imp))
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Creating_an_image_of_the_same_type_of_an_existing_one">Creating an image of the same type of an existing one</span></h3>
<pre class="brush:clojure">
; The original
(def imp-1 (ImagePlus. "The source image" (FloatProcessor. 512 512)))

; The new empty image, of the same type as the old but larger
(def imp-2 (ImagePlus. "The larger image of the same type"
                       (.. imp-1 getProcessor (createProcessor 768 768))))
</pre>
<p>Above, notice the parenthesis (createProcessor 768 768), which specify for which method those numbers are arguments for.
</p>
<h3><span class="mw-headline" id="Resizing_an_image">Resizing an image</span></h3>
<p>The idea is to grab the ImageProcessor, duplicate it and resize it. The resizing returns a new ImageProcessor of the same type:
</p>
<pre class="brush:clojure">
(def imp-1 (IJ/openImage "/path/to/image1.tif"))

(def imp-2 (ImagePlus. "A new larger one" (.. imp-1 getProcessor (createProcessor 1024 1024))))

; Copy one into the other at top-left (hence 0,0 insert point):
(doto (.getProcessor imp-2)
  (.insert (.getProcessor imp-1) 0 0))
</pre>
<p>An alternative way would be to simply duplicate the processor of imp-1, and then enlarge it:
</p>
<pre class="brush:clojure">
(def imp-3 (ImagePlus. "A copy with extra empty space"
                       (.. imp-1 getProcessor duplicate (resize 768 768)))
</pre>
<h3><span class="mw-headline" id="Resizing_an_ImageStack">Resizing an ImageStack</span></h3>
<p>This one is harder, because an ImageStack is just a wrapper for Object[] list of pixel arrays.
ImageJ though provides a mid-level resizing method, via the <a rel="nofollow" class="external text" href="developer/api/ij/plugin/CanvasResizer.html">CanvasResizer</a> class:
</p><p><br />
</p>
<pre class="brush:clojure">
(import '(ij.plugin CanvasResizer)
        '(ij IJ ImagePlus))

; Grab the image in the currently active ImageWindow:
(def imp-1 (IJ/getImage))

; function to resize images:
(defn resize-image
  "Takes an ImagePlus as argument and returns a new ImagePlus
   but resized to width,height, and with the contents copied 
   starting from xoff,yoff"
  [imp w h xoff yoff]
  (let [resizer (CanvasResizer.)
        stack (.getStack imp)
        imp-2 (ImagePlus. (.getTitle imp)
                (if stack
                  (.expandStack resizer stack w h xoff yoff)
                  (.expandProcessor resizer w h xoff yoff)))]
    imp-2))

(def imp-2 (resize-image imp-1 1024 1024 0 0))

(.show imp-2)
</pre>
<p>Note that the above function <i>resize-image</i> will work for both stacks and non-stack images.
</p><p>Of course nothing stops you from looping through the stack length, calling a new ImageProcessor for each slice, resizing it, composing a new ImageStack and with it a new ImagePlus.
</p>
<pre class="brush:clojure">
; Grab the image in the currently active ImageWindow:
(def imp-1 (IJ/getImage))

(defn resize-stack
  "Resize an ImageStack to new widht,height
   and copy its contents starting at xoff,yoff coordinate."
  [stack w h xoff yoff]
  (let [new-stack (ImageStack. w h nil)]
    (doseq [i (range 0 (.getSize stack))]
      (let [ip (.getProcessor stack (+ i 1))
            #^ImageProcessor ip2 (.createProcessor ip w h)]
        (.insert ip2 ip xoff yoff)
        (.addSlice new-stack (str i) ip2)))
    new-stack))
</pre>
<p>Above, note that <b>stacks are 1-based,not 0-based!</b>
</p><p>Also, we must declare the type of the <i>ip2</i> because clojure cannot decide between the ImageProcessor.addSlice(String,ImageProcessor) and ImageProcessor.addSlice(String,Object). You must make that choice for clojure.
</p><p>Notice that each time you call getProcessor on an ImageStack, it returns a new ImageProcessor instance in a very costly way, by calling a series of <i>instanceof</i> on the pixels arrays to figure out which kind of ImageProcessor subclass it should create.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Resizing_an_image_or_ImageStack_using_ROIs">Resizing an image or ImageStack using ROIs</span></h3>
<p>ROIs (aka Region of Interest or selection) have bounds, defined by the minimal enclosing rectangle.
</p><p>The core idea is to set a ROI to an ImageProcessor and call <i>crop</i> to obtain a new, subcopy of it.
</p><p><br />
</p>
<pre class="brush:clojure">
(def imp (IJ/getImage))

(def imp-cropped (ImagePlus. "Cropped"
                             (let [ip (.getProcessor imp)]
                               (.setRoi ip (Roi. 10 10 200 200))
                               (.crop ip))))

(.show imp-cropped)
</pre>
<p><br />
To handle any ImagePlus (with single slice or containing an ImageStack, i.e. many slices), see this function:
</p><p>(which assumes the ROI is contained fully within the image; otherwise for stacks it will throw an Exception stating that, rightly, dimensions do not match.)
</p>
<pre class="brush:clojure">
(import '(ij.gui Roi)
        '(ij ImagePlus)
        '(ij.process ImageProcessor))

(def imp (IJ/getImage))

(defn crop-image
  "Crop an image by the bounds of a ROI,
   returning a new ImagePlus with the result."
  [imp roi]
  (let [crop-processor (fn [ip roi]
                         (.setRoi ip roi)
                         (.crop ip))
        stack (.getStack imp)]
   &#160;; Return a new ImagePlus with a new cropped ImageProcessor 
   &#160;; or a new cropped ImageStack:
    (ImagePlus. (.getTitle imp)
      (if stack
        (let [box (.getBounds roi)
              new-stack (ImageStack. (.width box) (.height box) nil)]
          (doseq [i (range (.getSize stack))]
            (.addSlice new-stack (.getSliceLabel stack (+ i 1))
                       #^ImageProcessor (crop-processor 
                                          (.getProcessor stack (+ i 1))
                                          roi)))
          new-stack)
       &#160;; Else single slice image:
        (crop-processor (.getProcessor imp) roi)))))

(def imp-cropped (crop-image imp (Roi. 100 100 300 300))

(.show imp-cropped)
</pre>
<p>The above works with both single images and stacks.
</p>
<h2><span class="mw-headline" id="Manipulate_images_using_ImgLib">Manipulate images using ImgLib</span></h2>
<p>With <a href="Imglib" class="mw-redirect" title="Imglib">Imglib</a>, pixels are stored in native arrays of primitives such as int, float, double, etc. (or other more interesting forms, such as <a rel="nofollow" class="external text" href="http://download.oracle.com/javase/1.5.0/docs/api/java/awt/Shape.html">Shape</a>. Such pixels are accessed with intermediate proxy objects that the JIT is able to completely remove out of the way.
</p><p>From Clojure, there are many ways in which to access the pixels. Here we list some examples of the pixels accessed as a Collection of accessor <a rel="nofollow" class="external text" href="https://fiji.sc/javadoc/mpicbg/imglib/type/Type.html">Type</a> objects.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Multiply_each_pixel_by_0.5">Multiply each pixel by 0.5</span></h3>
<p>Multiply in place each value by 0.5. The ImgLib/wrap is a thin wrapper that accesses directly the pixel array. Hence the original image will be changed.
</p>
<pre class="brush:clojure">
; ASSUMES the current image is 32-bit
(ns test.imglib
 (:import [mpicbg.imglib.image Image]
          [script.imglib ImgLib]
          [mpicbg.imglib.type.numeric.real FloatType]
          [ij IJ]))

(set! *warn-on-reflection* true)

(let [^Image img (ImgLib/wrap (IJ/getImage))
     a (float 0.5)]
 (doseq [^FloatType t img]
   (.mul t a)))
</pre>
<p>In a more functional style, below we create an image with the same dimensions as the wrapped image, and set its pixel values to those of the original image times 0.5:
</p>
<pre class="brush:clojure">
(ns test.imglib
 (:import [mpicbg.imglib.image Image]
          [mpicbg.imglib.cursor Cursor]
          [script.imglib ImgLib]
          [mpicbg.imglib.type.numeric NumericType]
          [ij IJ]))

(set! *warn-on-reflection* true)

(let [^Image img (ImgLib/wrap (IJ/getImage))
      a (float 0.5)
      ^Image copy (.createNewImage img "copy")]
  (with-open [^Cursor c1 (.createCursor img)
              ^Cursor c2 (.createCursor copy)]
    (loop []
      (if (.hasNext c1)
        (do
          (.fwd c1)
          (.fwd c2)
          (let [^NumericType t1 (.getType c1)
                ^NumericType t2 (.getType c2)]
            (.set t2 t1)
            (.mul t2 a))
          (recur)))))
  (.. copy getDisplay setMinMax)
  (.show (ImgLib/wrap copy)))
</pre>
<p>The above, though, is unbearably verbose. A high-level access to the images enables mathematical operations without trading off any performance:
</p>
<pre class="brush:clojure">
(ns test.imglib
 (:import [mpicbg.imglib.image Image]
          [mpicbg.imglib.cursor Cursor]
          [script.imglib ImgLib]
          [script.imglib.math Compute Multiply]
          [ij IJ]))

(set! *warn-on-reflection* true)

(let [^Image img (ImgLib/wrap (IJ/getImage))
      ^Image copy (Compute/inFloats (Multiply. img 0.5))]
    (.. copy getDisplay setMinMax)
    (.show (ImgLib/wrap copy)))
</pre>
<p>What's more, the <a rel="nofollow" class="external text" href="https://fiji.sc/javadoc/script/imglib/math/Compute.html">Compute</a>/inFloats method runs in parallel, with as many processors as your machine has cores. If you'd rather not execute the operation in parallel, add the desired number of threads as an argument to <i>inFloats</i>.
</p><p>All mathematical operations listed in java.lang.Math have a corresponding constructor for execution in Compute/inFloats. See the documentation for the <a rel="nofollow" class="external text" href="https://fiji.sc/javadoc/script/imglib/math/package-frame.html">script.imglib.math package</a>.
</p>
<h3><span class="mw-headline" id="Normalize_an_image">Normalize an image</span></h3>
<p>Assumes that <i>(IJ/getImage)</i> returns a 32-bit, float image. If that is not the case, convert the image to a float image first.
</p><p>The example below creates a new result image. The original image is untouched. This is accomplished with minimal friction but best performance (like hand-coded with cursors or better) by using the high-level scripting library of imglib, and the <a rel="nofollow" class="external text" href="https://fiji.sc/javadoc/script/imglib/math/Compute.html">Compute</a>/inFloats method.
</p>
<pre class="brush:clojure">
(ns test.imglib
 (:import [mpicbg.imglib.image Image]
          [script.imglib ImgLib]
          [script.imglib.math Compute Subtract Divide]
          [ij IJ]))


(let [^Image img (ImgLib/wrap (IJ/getImage))
     size (.size img)
     mean (reduce
            #(+&#160;%1 (/ (.getRealFloat&#160;%2) size))
            (float 0)
            img)
     variance (/ (reduce
                   #(+&#160;%1 (Math/pow (- (.getRealFloat&#160;%2) mean) (float 2)))
                   (float 0)
                   img)
                 size)
     std-dev (Math/sqrt variance)
     ^Image normalized (Compute/inFloats (Divide. (Subtract. img
mean) std-dev))]
 (.. normalized getDisplay setMinMax)
 (.show (ImgLib/wrap normalized)))
</pre>
<p>There is a better way to compute the mean and variance of a collection of numbers, that involves traversing the collection only once. Clojure naturally helps with its very concise destructuring and its automatic promotion of numeric types to avoid overflow.
</p>
<pre class="brush:clojure">
(ns test.imglib
 (:import [mpicbg.imglib.image Image]
          [mpicbg.imglib.type.numeric RealType]
          [script.imglib ImgLib]
          [script.imglib.math Compute Subtract Divide]
          [ij IJ]))

(set! *warn-on-reflection* true)
 
(let [^Image img (ImgLib/wrap (IJ/getImage))
      size (.size img)
      [xs x2s] (reduce (fn [accum ^RealType t]
                         (let [xi (.getRealFloat t)]
                           [(+ (accum 0) xi)
                            (+ (accum 1) (* xi xi))]))
                       [0 0]
                       img)
      mean (/ xs size)
      variance (- (/ x2s size) (* mean mean))
      std-dev (Math/sqrt variance)
      ^Image normalized (Compute/inFloats (Divide. (Subtract. img mean) std-dev))]
  (.. normalized getDisplay setMinMax)
  (.show (ImgLib/wrap normalized)))
</pre>
<p>(Code adapted from a Common Lisp version by <a rel="nofollow" class="external text" href="http://nklein.com/2011/02/calculating-the-mean-and-variance-with-one-pass/">Patrick Stein</a>.)
</p>
<h2><span class="mw-headline" id="Looping_an_array_of_pixels">Looping an array of pixels</span></h2>
<p>For example, to find the min and max values:</p>
<pre class="brush:clojure">
; Obtain the pixels array from the current image
(let [imp (ij.WindowManager/getCurrentImage)
      pixels (.. imp getProcessor getPixels)
      min (apply min pixels)
      max (apply max pixels)]
    (println (str "min: " min ", max: " max)))
</pre>
<p>The above code does not explicitly loop the pixels: it simply applies a function to an array.</p>
<p>To loop pixels one by one, use any of the following:</p>
<pre class="brush:clojure">
(let [imp (ij.WindowManager/getCurrentImage)
      pixels (.. imp getProcessor getPixels)]

     &#160;; First loop with "dotimes"
      (dotimes [i (count pixels)]
          (println (aget pixels i)))

     &#160;; Second loop: with "loop -- recur"
      (loop [i 0
             len (count pixels)]
         (if (&lt; i len)
            (do
               (println (str i ": " (aget pixels i)))
               (recur (inc i)
                      len)))))

</pre>                                                                                                                                                                                                                
<p>Above, notice that the <i>loop -- recur</i> construct is essentially a <i>let</i> declaration, with a second call (<i>recur</i>) to reset the variables to something else. In this case, the next index in the array. Note how the len is simply given the same value over and over, just to avoid calling <i>(count pixels)</i> at each iteration.</p>
<p>Of course, there are lispier ways to loop an array of pixels. For example, to obtain the average of all pixels, we can use function <i>reduce</i>, which takes the first two elements of a list, applies a function to them, and then applies the function to the result and the next element, etc:</p>
<pre class="brush:clojure">
(let [fp (.getProcessor (ij.IJ/getImage))
      pix (.getPixels fp)]
   (if (instance? ij.process.FloatProcessor fp)
      (println "Average pixel intensity" (/ (reduce + pix) (count pix)))
      (println "Not a 32-bit image")))
</pre>
<p>Above, notice that one could have used also <i>apply</i> to apply <i>+</i> to all element of an array, with the same result:</p>
<pre class="brush:clojure">
      (println "Average pixel intensity" (/ (apply + pix) (count pix)))
</pre>
<p>To sum all pixels in an 8-bit image, one needs first to bit-and all bytes to 255, so they become integers and can be summed. But of course we should not <i>bit-and</i> the sum! To solve this, <i>reduce</i> accepts a first value (in this case, zero):</p>
<pre class="brush:clojure">
(let [bp (.getProcessor (ij.IJ/getImage))
      pix (.getPixels bp)]
  (if (instance? ij.process.ByteProcessor bp)
    (println "Average intensity: " (float (/ (reduce (fn [x1 x2] (+ x1 (bit-and x2 255))) 0 pix) (count pix))))
    (println "Not an 8-bit image")))
</pre>
<p>It could even be done using a local variable, but it's ugly and undesirable (why create it when it's not really needed)? Notice we need to create the local variable "sum" because variables declared by <i>let</i> are immutable.</p>
<pre class="brush:clojure">
(let [bp (.getProcessor (ij.IJ/getImage))
      pix (.getPixels bp)]
  (if (instance? ij.process.ByteProcessor bp)
    (with-local-vars (sum 0)
      (doseq [pixel pix]
        (var-set sum (+ (var-get sum) (bit-and pixel 255))))
      (println (float (/ (var-get sum) (count pix)))))
    (println "Not an 8-bit image")))
</pre>
<h2><span class="mw-headline" id="Executing_commands_from_the_menus">Executing commands from the menus</span></h2>
<p>Any ImageJ menu command may be run on the active image:</p>                                                                                                                                                        
<pre class="brush:clojure">
(ij.IJ/doCommand "Add Noise")
</pre>
<p>Be aware that the above starts a new Thread and forks. For reliable control, try the run method, which will wait until the plugin finishes execution.</p>
<pre class="brush:clojure">
(ij.IJ/run "Add Noise")
</pre>
<p>For even more reliable control, run the command directly on a specified image, instead of a possibly changing current image:
</p>
<pre class="brush:clojure">
(let [imp (ij.IJ/getImage)]
  (ij.IJ/run imp "Subtract..." "value=25"))
</pre>
<p>To find out which arguments can any command accept, open the Plugins - Macros - Macro Recorder and run the command manually.
</p>
<h2><span class="mw-headline" id="Creating_and_using_Clojure_scripts_as_ImageJ_plugins">Creating and using Clojure scripts as ImageJ plugins</span></h2>
<p>Simply create a text file with the script inside, and place it in the plugins menu or any subfolder. Then call Plugins - Scripting - Refresh Clojure Scripts to make it appear on the menus.</p>
<p>If the macros/StartupMacros.txt includes a call to the Refresh Clojure Scripts inside the AutoRun macro, then all your Clojure scripts will appear automatically on startup.</p>
<p>To modify an script which exists already as a menu item, simply edit its file and run it by selecting it from the menus. No compiling necessary, and no need to call Refresh Clojure Scripts either (ther latter only for new scripts or at start up.)</p>
<p><b>Very important:</b> all scripts and commands from the interpreter will run within the same thread, and within the same clojure context.</p>
<h2><span class="mw-headline" id="Using_java_beans_for_quick_and_convenient_access_to_an_object.27s_fields">Using java beans for quick and convenient access to an object's fields</span></h2>
<p>Essentially it's all about using <i>get</i> methods in a trivial way. For example:</p>
<pre class="brush:clojure">
(let [imp (ij.WindowManager/getCurrentImage)
      b (bean imp)]
   (println (:title b)
            (:width b)  
            (:height b)))
</pre>                                                                                                                                                                                                                
<p>Eventually Clojure may add support for <i>set</i> methods as well.</p>
<h1><span class="mw-headline" id="Examples">Examples</span></h1>
<h2><span class="mw-headline" id="Fixing_overexposed_images:_setting_a_pixel_value_to_a_desirable_one_for_all_overexposed_pixels">Fixing overexposed images: setting a pixel value to a desirable one for all overexposed pixels</span></h2>
<p>The problem: <a rel="nofollow" class="external text" href="http://ami.scripps.edu/software/leginon/">Leginon</a> or the Gatan TEM camera acquired an overexposed image, and set all pixels beyond range to zero.
</p><p>The solution: iterate all pixels; if the pixel is zero then set it to a desirable value, such as the maximum value of the main curve in the histogram (push 'auto' on the Brightness and Contrast dialog to see it.)
</p><p>In the example below, the <i>fix</i> function is called with the current image and the value 32500 as a floating point number. Notice also the type definition (which is optional) of the float pixel array, to enhance execution speed:
</p>
<pre class="brush:clojure">

 ; Assumes a FloatProcessor image
 (defn fix [imp max]
 (let [#^floats pix (.getPixels (.getProcessor imp))]
   (loop [i (int 0)]
     (if (&lt; i (alength pix))
       (do
         (if (= 0 (aget pix i)) (aset pix i (float max)))
         (recur (inc i)))))))
 
 (let [imp (ij.IJ/getImage)]
   (fix imp (float 32500))
   (.updateAndDraw imp))
</pre>
<h2><span class="mw-headline" id="Creating_a_script_for_ImageJ">Creating a script for ImageJ</span></h2>
<p>Simply write the clojure script in a text file, and follow these conventions:
</p>
<pre>1. Add an underscore "_" to its file name, and the extension ".clj": fix_leginon_images.clj
2. Save it under fiji/plugins/ folder, or a subfolder.
</pre>
<p>When done, just run the <span><em><span style="border-bottom:1px dotted #ccc;">PlugIns</span>&#160;&#8250; <span style="border-bottom:1px dotted #ccc;">Scripting</span>&#160;&#8250; <span style="border-bottom:1px dotted #ccc;">Refresh Clojure Scripts</span></em></span> plugin.
</p><p>Once saved and in the menus, you need <b>not</b> call refresh scripts ever again for that script. Just edit and save it's text file, and run it again from the menus. Next time Fiji opens, the script will automatically appear in the menus.
</p><p>See <a href="Scripting_Help" class="mw-redirect" title="Scripting Help">Scripting Help</a> for more details, including how to use the built-in dynamic interpreter.
</p>
<h2><span class="mw-headline" id="Example_Clojure_plugins_included_in_Fiji">Example Clojure plugins included in Fiji</span></h2>
<p>Open the plugins/Examples/ folder in Fiji installation directory. You'll find three Clojure examples:
</p>
<ul><li> <a rel="nofollow" class="external text" href="https://github.com/fiji/fiji/blob/master/plugins/Examples/Multithreaded_Image_Processing.clj">Multithreaded_Image_Processing.clj</a>: illustrate, with macros (via <a rel="nofollow" class="external text" href="http://clojure.org/macros#toc9">defmacro</a>), how to automatically multithread the processing of an image using arbitrary subdivision of the image, such as one line per thread, for as many threads as cores the CPU has.</li>
<li> <a rel="nofollow" class="external text" href="https://github.com/fiji/fiji/blob/master/plugins/Examples/blend_two_images.clj">blend_two_images.clj</a>: illustrates how to open two images from an URL, and blend the gray image into each channel of the color image.</li>
<li> <a rel="nofollow" class="external text" href="https://github.com/fiji/fiji/blob/master/plugins/Examples/celsius_to_fahrenheit.clj">celsius_to_fahrenheit.clj</a>: illustrates the usage of a Swing GUI, and how to instantiate anonymous classes from an interface (via <a rel="nofollow" class="external text" href="http://clojure.org/java_interop#toc20">proxy</a> Clojure function). This example is taken from the <a rel="nofollow" class="external text" href="http://clojure.org/jvm_hosted">Clojure website</a>.</li>
<li> <a rel="nofollow" class="external text" href="https://github.com/fiji/fiji/blob/master/plugins/Examples/random_noise_example.clj">random_noise_example.clj</a>: illustrates how to declare a function inside a closure (for private access to, in this case, a unique instance of a random number generator), and then fill all pixels of a ByteProcessor image with a random byte value.</li>
<li> <a rel="nofollow" class="external text" href="https://github.com/fiji/fiji/blob/master/plugins/Examples/Command_Launchers/Command_Launcher_Clojure.clj">Command_Launcher_Clojure.clj</a>: illustrates how to create a GUI with a KeyListener, so that the typed text changes color from red to black when it matches the name of an ImageJ command. This example is also under the <a href="Scripting_comparisons" title="Scripting comparisons">Scripting comparisons</a>, along equivalent versions written in Java, <a href="Jython_Scripting" title="Jython Scripting">Jython</a>, <a href="Javascript_Scripting" class="mw-redirect" title="Javascript Scripting">Javascript</a> and <a href="JRuby_Scripting" title="JRuby Scripting">JRuby</a>.</li>
<li> <a rel="nofollow" class="external text" href="https://github.com/fiji/fiji/blob/master/plugins/Analyze/Dynamic_ROI_Profiler.clj">Dynamic ROI Profiler</a>: illustrates how to add a MouseMotionListener and a WindowListener to an ImageWindow of an open image. Reads out the ROI (Region Of Interest), and if it's a line, polyline or rectangle, plots the profile of pixel intensity along the line. As the mouse moves or edits the ROI on the image, the profile is updated.</li></ul>
<h1><span class="mw-headline" id="Appendix">Appendix</span></h1>
<h2><span class="mw-headline" id="Defining_the_output_stream">Defining the output stream</span></h2>
<p>The default output stream is at variable <i>*out*</i>, which you may redefine to any kind of PrintWriter:
</p>
<pre class="brush:clojure">
(let [all-out (new java.io.StringWriter)]
  (binding [*out* all-out]
    &#160;; any typed input here
    &#160;; All calls to pr, prn, println will print into all-out
     (println "this and that")
   )
  &#160;; Now show any printed out text in ImageJ's log window:
   (ij.IJ/log (str all-out)))
</pre>
<h2><span class="mw-headline" id="Destructuring">Destructuring</span></h2>
<p>Destructuring is a shortcut to capture the contents of a variable into many variables.
</p><p>An example: when looping a map, we get the entry, not the key and value of each entry:
</p>
<pre class="brush:clojure">
(doseq [e {:a 1&#160;:b 2&#160;:c 3}]
  (println e))
</pre>
<p>Prints:
</p>
<pre>[:a 1]
[:b 2]
[:c 3]
nil
</pre>
<p>Each "entry" is represented by a vector with two values.
</p><p>Now to loop more conveniently, we can assign the key and value to variables, by what is called destructuring (note the <i>[k v]</i> where the <i>e</i> was before)
</p>
<pre class="brush:clojure">
(doseq [[k v] {:a 1&#160;:b 2&#160;:c 3}]
  (println k v))
</pre>
<p>Prints:
</p>
<pre>:a 1
:b 2
:c 3
nil
</pre>
<p>Even better, we can preserve the whole entry as well, by using the keyword ":as":
</p>
<pre class="brush:clojure">
(doseq [[k v&#160;:as e] {:a 1&#160;:b 2&#160;:c 3}]
  (println k v e))
</pre>
<p>Prints:
</p>
<pre>:a 1 [:a 1]
:b 2 [:b 2]
:c 3 [:c 3]
nil
</pre>
<h2><span class="mw-headline" id="Namespaces">Namespaces</span></h2>
<ul><li> To list all existing namespaces:</li></ul>
<pre class="brush:clojure">
&gt;&gt;&gt; (all-ns)
(#&lt;Namespace: xml&gt; #&lt;Namespace: zip&gt; #&lt;Namespace: clojure&gt; #&lt;Namespace: set&gt; #&lt;Namespace: user&gt;)
</pre>
<ul><li> To list all functions and variables of a specific namespace, first get the namespace object by name:</li></ul>
<pre class="brush:clojure">
(ns-map (find-ns 'xml))
</pre>
<p>Note above the quoted string "xml" to avoid evaluating it to a (non-existing) value.
</p>
<ul><li> To list all functions and variables of all namespaces:</li></ul>
<pre class="brush:clojure">
(map ns-map (all-ns))
</pre>
<p>A nicer way to print all public functions and variables from all namespaces, sorted alphabetically:
</p>
<pre class="brush:clojure">
(doseq [name (all-ns)]
  (doseq [[k v] (sort (ns-publics name))]
    (println k v)))
</pre>
<p>Note above we use <i>destructuring</i>: the [k v] take the values of the key and the value of each entry in the ns-publics table. Actually, since we first sort the table, the k and v take the first and second values of each array pair in the sorted list of array pairs returned on applying <i>sort</i> to the <i>ns-publics</i>-generated table.
</p>
<h2><span class="mw-headline" id="Forget.2FRemove_all_variables_from_a_namespace">Forget/Remove all variables from a namespace</span></h2>
<p>To forget all variables from the user namespace, do:
</p>
<pre class="brush:clojure">
(map #(ns-unmap 'user&#160;%)
     (keys (ns-interns 'user)))
</pre>
<p>The above maps the function <i>ns-unmap</i> to each variable name declared in the <i>user</i> namespace (using # to create a <a href="Command_Launcher_Clojure.html#Lambda_functions" title="Clojure Scripting">lambda function</a>), which is the same as the prompt namespace. To get the names of the variables, we use <i>ns-interns</i> to retrieve the map of variable names versus the variable contents, and extract the keys from it into a list.
</p><p><i>Thanks to AWizzArd from #clojure at irc.freenode.net for the tip.</i>
</p>
<h2><span class="mw-headline" id="JVM_arguments">JVM arguments</span></h2>
<ul><li> To get the arguments passed to the JVM, see contents of variable *command-line-args*</li></ul>
<pre class="brush:clojure">
(println *command-line-args*)
</pre>
<h2><span class="mw-headline" id="Reflection">Reflection</span></h2>
<ul><li> To list all methods of an object:</li></ul>
<pre class="brush:clojure">
(defn print-java-methods [obj]
  (doseq [method (seq (.getMethods (if (= (class obj) java.lang.Class)
                                    (identity obj)
                                    (class obj))))]
    (println method)))
 
 ; Inspect an object named imp, perhaps an image
 (print-java-methods imp)

 public synchronized boolean ij.ImagePlus.lock()
 public void ij.ImagePlus.setProperty(java.lang.String,java.lang.Object)
 public java.lang.Object ij.ImagePlus.getProperty(java.lang.String)
 ...
</pre>
<ul><li> To list constructors, just use <i>.getConstructors</i> instead of <i>.getMethods</i>.</li></ul>
<p>(Thanks to Craig McDaniel for posting the above function to Clojure's mailing list.)
</p>
<h2><span class="mw-headline" id="Lambda_functions">Lambda functions</span></h2>
<h3><span class="mw-headline" id="Declaration">Declaration</span></h3>
<ul><li> To declare functions on the fly, lambda style, with regex for arguments:</li></ul>
<p>For example, declare a function that takes 2 arguments, and returns the value of the first argument divided by 10, and multiplied by the second argument:
</p>
<pre class="brush:clojure">
(let [doer #(* (/&#160;%1 10)&#160;%2)]
  (doer 3 2))
</pre>
<p>Of course there's no need to name the function, the above is just for illustration.
</p>
<h3><span class="mw-headline" id="Mapping_a_function_to_all_elements_in_a_list">Mapping a function to all elements in a list</span></h3>
<ul><li> To declare a nameless function, and apply it to each element of a list:</li></ul>
<p>In this case, increment by one each value of a list from 0 to 9:
</p>
<pre class="brush:clojure">
(let [numbers (range 10)
      add-one (fn [x] (+ x 1))]
  (map add-one numbers))
</pre>
<p>There is no need to declare the names, the above is just for illustration.
Above, we could have defined the function as #(+&#160;%1 1):
</p>
<pre class="brush:clojure">
(map #(+&#160;%1 1) (range 10))
</pre>
<p>... or of course use the internal function <i>inc</i> which does exactly that:
</p>
<pre class="brush:clojure">
(map inc (range 4))
</pre>
<p>Beware that the <i>map</i> function above applies the given function to each element of a list, and returns a <b>new</b> list with the results.
</p>
<h2><span class="mw-headline" id="Built-in_documentation">Built-in documentation</span></h2>
<p>Use the function <b><i>doc</i></b> to query any other function or variable. For example, the list generator function <i>range</i>:
</p>
<pre class="brush:clojure">
(doc range)

-------------------------
clojure/range
([end] [start end] [start end step])
  Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0 and step to 1.
</pre>
<p>Above, notice the function has three groups of possible arguments, denoted in brackets.
</p><p>When not knowing what to search for, you may try <b><i>find-doc</i></b> instead, which takes a string or regular expression as argument:
</p>
<pre> user=&gt; (find-doc "ns-")
 -------------------------
 clojure.core/ns-aliases
 ([ns])
   Returns a map of the aliases for the namespace.
 -------------------------
 clojure.core/ns-imports
 ([ns])
   Returns a map of the import mappings for the namespace.
 
 ... etc.
</pre>
<h3><span class="mw-headline" id="Defining_documentation_for_your_own_functions">Defining documentation for your own functions</span></h3>
<p>So where does the documentation come from? Every definition of a function or macro or multimethod may take a description string before the arguments:
</p>
<pre class="brush:clojure">
(defn area
  "Computes the area of a rectangle."
  [r]
  (* (.width r) (.height r)))
</pre>
<p>... which the <i>doc</i> function prints, formatted:
</p>
<pre> user=&gt; (doc area)                           
 -------------------------
 user/area
 ([r])
   Computes the area of a rectangle.
 nil
</pre>
<h3><span class="mw-headline" id="Defining_documentation_for_a_variable">Defining documentation for a variable</span></h3>
<pre class="brush:clojure">
(def
  #^{:doc "The maximum number of connections"}
  max-con 10)
</pre>
<p>... which the <i>doc</i> function prints as:
</p>
<pre> user=&gt; (doc max-con)
 -------------------------
 user/max-con
 nil
   The maximum number of connections
 nil
</pre>
<p>Function documentation is internally set like the above: <i>defn</i> is a macro that defines a function and puts the second argument as the doc string of the variable that points to the function body (among many other things).
</p>
<h3><span class="mw-headline" id="Adding_a_test_function_to_a_variable">Adding a test function to a variable</span></h3>
<p>We first declare the variable, and then define it with a metadata map that includes a test function:
</p>
<pre class="brush:clojure">
(declare a)
(def
  #^{:test #(if (&lt; a 10) (throw (Exception. "Value under 10!")))}
  a 6)
</pre>
<p>... which we then test, by invoking the function <i>test</i> not on the value of the variable <i>a</i> (which could have its own metadata map), but on the variable <i>a</i> itself, referred to with the <i>#'a</i>:
</p>
<pre class="brush:clojure">
(test #'a)
</pre>
<p>The test results, in this case, in an exception being thrown:
</p>
<pre>java.lang.Exception: Value under 10!
</pre>
<p>Otherwise, it would just return the <i>:ok</i> keyword.
</p>
<h2><span class="mw-headline" id="A_fibonacci_sequence:_lazy_and_infinite_sequences">A fibonacci sequence: lazy and infinite sequences</span></h2>
<p>A beautiful example of using lazy sequences and applying functions to one or more sequences at a time.
</p><p>Below, the sequence <i>fibs</i> is defined in such a way that it contains all possible <a href="http://en.wikipedia.org/wiki/Fibonacci_number" class="extiw" title="wikipedia:Fibonacci number">fibonacci numbers</a>. Since such sequence is infinite, we declared it as <i>lazy</i> sequence, that creates new elements only when they are asked for.
</p><p>The <i>lazy-cat</i> clojure function creates such lazy sequence by concatenation of two sequences: the first sequence is <i>0, 1</i> (which takes the role of feeder or initialization sequence), and the second sequence is the result of a <i>map</i> operation over two subsets of the <i>fibs</i> sequence itself: the full and the full minus the first element (hence the <i>rest</i> operation to obtain the list of all elements without the first).
</p><p>A <i>map</i> operation applies a function to each element of a sequence, or, when two or more sequences are provided, to the corresponding elements: those at index 0 in all sequences, those at index 1 in all sequences, etc.
</p><p>To generate the fibonacci sequence of numbers, a sum <i>+</i> operation is mapped to the numbers contained in the <b>self sequence</b> <i>fibs</i> and to the corresponding elements of the self sequence <i>fibs</i> minus the first element, i.e. <b>shifted by one</b>.
</p><p>In short, the lazy sequence <i>fibs</i> is an abstract way of representing a potentially infinite sequence, with an implementation containing a full abstract definition of <b>all</b> fibonacci numbers.
</p><p>Then we just <i>take</i> the first 10 elements of such lazy sequence, which are created on the fly.
</p>
<pre class="brush:clojure">
(def fibs (lazy-cat [0 1]
                    (map + fibs (rest fibs))))

(take 10 fibs)
</pre>
<p>Which outputs:
</p>
<pre>(0 1 1 2 3 5 8 13 21 34)
</pre>
<h3><span class="mw-headline" id="Printing_lazy_sequences_to_the_REPL">Printing lazy sequences to the REPL</span></h3>
<p>The REPL, when given a lazy sequence, will <b>traverse it in its entirety</b> to print it.
</p><p>Printing a potentially infinite lazy sequence to the REPL is something you don't want to do: besides triggering computation of each element, it would fill all memory and throw an OutOfMemoryException. And you'd get bored seeing elements pass by.
</p><p>A good option is to print only part of it:
</p>
<ul><li> <i>take</i>: the first N elements.</li>
<li> <i>drop</i>: all elements beyond N.</li>
<li> <i>nth</i>: the nth element only.</li></ul>
<p>For infinite lazy sequences, <i>drop</i> wouldn't save your REPL, and <i>take</i> could be perhaps too many still.
</p><p>To avoid accidental printing of complete lazy-sequences, you may set <b>*print-length*</b> to a reasonable number:
</p>
<pre class="brush:clojure">
(set! *print-length* 5)
</pre>
<p>So now one can safely print the entire fibonnaci sequence, which will print only the first 5 elements, followeed by dots:
</p>
<pre> user=&gt; (set! *print-length* 5)
 5
 user=&gt; fibs
 (0 1 1 2 3 ...)
</pre>
<p>The <b>*print-length*</b> applies to all sequences to be printed in the REPL, but is specially useful for very large lazy sequences.
</p>
<h2><span class="mw-headline" id="Creating_shallow_and_deep_sequences_from_java_arrays">Creating shallow and deep sequences from java arrays</span></h2>
<p>Many clojure functions take sequences, not native java arrays, as arguments. A java native array can be wrapped by a shallow sequence like the following:
</p>
<pre>&gt;&gt;&gt; (def pixels (into-array (range 10)))
#'user/pixels
&gt;&gt;&gt; pixels
[Ljava.lang.Integer;@f30d8e
&gt;&gt;&gt; (def seq-pix (seq pixels))
#'user/seq-pix
&gt;&gt;&gt; seq-pix
(0 1 2 3 4 5 6 7 8 9)
</pre>
<p>Now if we modify the native array, the sequence will reflect that change too when read:
</p>
<pre>&gt;&gt;&gt; (aset pixels 3 99)
99
&gt;&gt;&gt; seq-pix
(0 1 2 99 4 5 6 7 8 9)
</pre>
<p>The array was <b>not</b> duplicated. The only new object created was the shallow sequence:
</p>
<pre>&gt;&gt;&gt; (class seq-pix)
clojure.lang.ArraySeq
</pre>
<p>To create a true deep duplicate of the array, one can do:
</p>
<pre>&gt;&gt;&gt; (def pixels2 (vec pixels))
#'user/pixels2
&gt;&gt;&gt; (class pixels2)
clojure.lang.LazilyPersistentVector
&gt;&gt;&gt; pixels2
[0 1 2 99 4 5 6 7 8 9]
&gt;&gt;&gt; (def seq-pix2 (seq pixels2))
#'user/seq-pix2
&gt;&gt;&gt; (class seq-pix2)
clojure.lang.APersistentVector$Seq
</pre>
<p>Or, in short:
</p>
<pre>(def seq-pix2 (seq (vec pixels)))
#'user/seq-pix2
</pre>
<p>So now any changes to the original <i>pixels</i> array will not affect the new sequence:
</p>
<pre>&gt;&gt;&gt; (aset pixels 3 101)
101
&gt;&gt;&gt; seq-pix2
(0 1 2 99 4 5 6 7 8 9)
</pre>
<p><i>Thanks to Chouser and wwmorgan for examples on #clojure at irc.freenode.net</i>
</p>
<h2><span class="mw-headline" id="Generating_java_classes_in_.class_files_from_clojure_code">Generating java classes in .class files from clojure code</span></h2>
<p>Using ahead of time (AOT) compilation with <a rel="nofollow" class="external text" href="http://clojure.org/compilation">gen-class</a>, any clojure code can be compiled to a java class. Such class can then be used from java code, or from any scripting language like <a href="Jython_Scripting" title="Jython Scripting">jython</a>, <a href="JRuby_Scripting" title="JRuby Scripting">jruby</a>, <a href="Javascript_Scripting" class="mw-redirect" title="Javascript Scripting">javascript</a>, and <a href="./Category:Scripting" title="Category:Scripting">any other</a>.
</p><p>One way to do so is to place a <a rel="nofollow" class="external text" href="http://clojure.org/compilation">gen-class</a> declaration in a namespace block.
</p><p>Be aware: the <b>namespace</b> must match <b>the folder structure where the .clj file is and the file name of the .clj file</b>. For example, to generate a class named fj.tests.process.FloatProcessorPlus, you need a clojure file under fj/tests/process/FloatProcessorPlus.clj .
</p><p>To compile the clojure code to .class files, you need:
</p>
<ol>
<li>A <b>classes/</b> folder in the current directory where clojure.lang.Repl is run. This folder will receive the generated .class files.</li>
<li>Add to your classpath the top-level folder, in the example the 'fj' folder, and also the folder containing the .clj file itself.</li>
<li>Add to your classpath the classes/ folder as well.</li>
<li>In a clojure.lang.Repl, use the <i>compile</i> function.</li>
</ol>
<p>For example:
</p>
<pre class="brush:bash">
$ mkdir classes
$ java -cp .:../../ij.jar:../../jars/clojure.jar:./classes/:./fj/tests/process/ clojure.lang.Repl
</pre>
<pre>user=&gt; (compile 'fj.tests.process.FloatProcessorPlus)
fj.tests.process.FloatProcessorPlus
user=&gt;
</pre>
<p>The following clojure example contains a namespace declaration that includes some imports and also the gen-class.
In the gen-class block, we define which class our code extends (in this case, ij.process.FloatProcessor), and which methods are to be created (with specific argument signatures and return object signature).
</p><p>Later, the compiler will assign a clojure function to each declared method, using the prefix string plus the method name to match a function.
</p><p>For example, with prefix "fp-" and method "fillValue", the compiler will look for the clojure function "fp-fillValue".
</p><p>Finally, a main method is not directly declared, but exists if a function named prefix + main ("fp-main" in the example) exists. We can use the main method to run the new class as an application.
</p><p>The example clojure code:
</p>
<pre class="brush:clojure">
; Albert Cardona 20081203
; Save this file as fj/tests/process/FloatProcessorPlus.clj

; and compile it from a Repl or clojure script like:
;
; (compile 'fj.tests.process.FloatProcessorPlus)
;
; Be sure to set the classpath to point to the folder containing the above file, for example:
; $ cd fiji/plugins/
; $ mkdir -p tests/fj/tests/process
; $ cd tests/fj/tests/process/
; $ vim FloatProcessorPlus.clj
; ...
; $ cd ../../../
; $ mkdir classes
; $ java -cp ../../ij.jar:../../jars/clojure.jar:./classes/:.:./fj/tests/process/ clojure.lang.Repl
; user=&gt; (compile 'fj.tests.process.FloatProcessorPlus)
; fj.tests.process.FloatProcessorPlus
; user=&gt;
;
; The compilation will place the proper .class files under the proper directory
; structure in the ./classes/ folder.
;
; Then run like any other java class with a static public void main method:
; $ java -cp .:../../ij.jar:../../jars/clojure.jar:./classes fj.tests.process.FloatProcessorPlus
;

(ns fj.tests.process.FloatProcessorPlus
   (:import (ij ImagePlus)
            (ij.process FloatProcessor)
            (java.util Random))
   (:gen-class
   &#160;; Could also use&#160;:implements
   &#160;:extends ij.process.FloatProcessor
   &#160;; Specify methods to expose as public,
   &#160;; with specific parameter types and return type:
   &#160;:methods [[fillMin [] void]
              [fillMax [] void]
              [fillValue [float] void]
              [randomize [] void]]
   &#160;; Define a function prefix for the exposed methods: for example,
   &#160;; the fillMin public method is implemented by function fp-fillMin.
   &#160;:prefix "fp-"))

(defn fp-fillValue [this value]
  "Set each pixel in the image to the given value."
  (.setPixels this
              (into-array Float/TYPE (replicate
                            (* (.getWidth this) (.getHeight this))
                            (float value)))))

(defn fp-fillMin [this]
  (.fillValue this Float/MIN_VALUE))

(defn fp-fillMax [this]
  (.fillValue this Float/MAX_VALUE))
          
; Declaring a function to be used as a java method, within a closure:
(let [generator (Random. (System/currentTimeMillis))]
  (defn fp-randomize [this]  
    (.setPixels this (into-array Float/TYPE
                            (map
                              (fn [x] (.nextFloat generator))
                              (range (* (.getWidth this) (.getHeight this))))))))

    
; This function is seen as the static public void main function of a java class:
; (add a parameter, like [args], if you would like to access the command-line args)
(defn fp-main []
  "Test the generated class" 
  (let [imp (ImagePlus. "Test" (fj.tests.process.FloatProcessorPlus. 100 100))
        ip (.getProcessor imp)]&#160;; Testing access on "ImageProcessor" type
    (.show imp)
   &#160;; Test some methods of our extended FloatProcessor class:
    (.randomize ip)
    (.findMinAndMax ip)
    (.updateAndDraw imp)))
</pre>
<h2><span class="mw-headline" id="References.2C_concurrency.2C_transactions_and_synchronization">References, concurrency, transactions and synchronization</span></h2>
<p>Clojure supports thread concurrency without explicit locks. Compared to java code, this is a gigantic step forward: locks, and particularly multiple locks, are very hard to get right and very, very hard to debug properly (but see <a rel="nofollow" class="external text" href="http://albert.rierol.net/java_tricks.html#How%20to%20debug%20a%20multithreaded%20java%20program">debugging multithreaded java programs</a>).
</p><p>The most basic building blocks are <a rel="nofollow" class="external text" href="http://clojure.org/refs"><i>references</i></a>, which are created with the <i>ref</i> function, and modified within transaction blocks (defined by <i>dosync</i>) using <i>commute</i> or <i>alter</i> functions (and <a rel="nofollow" class="external text" href="http://clojure.org/refs">others</a>).
</p><p>To read out the value of a reference, call <i>deref</i> or just <i>@</i> on it:
</p>
<pre class="brush:clojure">
; Create a new reference named 'id' initializated to value zero:
(def id (ref 0))
-&gt; 0

; Read out the value of the reference:
@id
-&gt; 0

; Increase the id by one, using built-in function "inc":
(dosync (alter id inc))
-&gt; 1

; Set the value to 20 (ignoring the current value, given in cv:
(dosync (alter id (fn [cv] 20)))
-&gt; 20
</pre>
<p>References are not type specific: any object may be assigned to the same reference. Whether that makes any sense is up to you.
</p><p>The <i>commute</i> and <i>alter</i> functions replace the value of the reference with that of the return value of a function given as argument. The function given as argument to <i>commute</i> and <i>alter</i> is given, in turn, the value of the reference (i.e. the dereferenced reference) and any other further arguments. The difference between <i>commute</i> and <i>alter</i> is that <i>commute</i> returns the dereferenced reference after the transaction is done, which may be different already (because of concurrent modifications) than the value that was set to the reference within the transaction; whereas <i>alter</i> returns the value that it had while the transaction was being done (i.e. the value returned by the function, the same that gets set as the value of the reference).
</p><p>In the following example, a unique id counter is incremented continuously by 1, and all ids are collected, unordered, into a vector. Both the next available id and the vector of all accessed ids are stored in references.
</p><p>Keep in mind the vector of ids assigned to the reference named 'ls' is always immutable: what we assign to the reference 'ls' below is a new vector, resulting from adding a new id to the old vector of ids. This immutability enables other threads to read the vector without locks. For performance, keep in mind that vectors, like many other clojure data structures, have structural sharing, so the new vector is not a duplication--even if it behaves like one.
</p><p>The assignment is done in a transaction, so no matter how many concurrent threads try to do so, the resulting vector will have all the ids.
</p>
<pre class="brush:clojure">
; Albert Cardona 2008-12-18
; Example clojure program using references and concurrent threads
; that alter the value of the references.
;
; 10 threads running concurrently
; each thread runs 100000 iterations
; in each iteration the thread increments a counter 'id'
;   and adds it to a list 'ls' of ids.
; At the end, we print the current value of 'id'
; and the length of the list 'ls' of ids.
;
; No locks!

(ns fj.test.concurrent
  (:import (java.util.concurrent Executors TimeUnit)))


(let [ls (ref [])&#160;; A reference to a vector storing a list if ids.
      id (ref 0) &#160;; The next unique id available.
      n_threads 10
      n_iterations 100000
      exec (Executors/newFixedThreadPool n_threads)]
  (println "Running" n_threads "threads x" n_iterations "iterations/thread...")
  (dotimes [i n_threads]
    (.submit exec (fn []
                    (dotimes [t n_iterations]
                     &#160;; Obtain the next unique id:
                     &#160;; (Note we use "alter" and not "commute", because alter
                     &#160;; returns the result of the applied function, whereas
                     &#160;; commute would return the dereferenced ref, which could
                     &#160;; have already changed.  Thanks to AWizzards for spotting
                     &#160;; this.)
                      (let [next-id (dosync (alter id inc))]
                       &#160;; Create a new vector made of
                       &#160;;  all previous ids and next-id,
                       &#160;;  and set it as the current list of ids:
                        (dosync (commute ls conj next-id)))))
                   nil))
  (.shutdown exec)
  (.awaitTermination exec 10 TimeUnit/MINUTES)
  (println "... done!")
 &#160;; If there was any clash in setting the reference to the list of ids,
 &#160;; the count would be less than 1000000:
  (println "Number of listed ids:" (count @ls))
 &#160;; If any id was used twice, the next available id would be less than 1000000:
  (println "Next available id:" @id)
 &#160;; Check that there aren't any repeated ids:
  (println "Number of repeated ids:"
           (- (count @ls)
              (count (set @ls)))))&#160;; Make a hash set (with unique entries) from the list of ids
</pre>
<h2><span class="mw-headline" id="Using_try.2Fcatch.2Ffinally_and_throwing_Exceptions">Using try/catch/finally and throwing Exceptions</span></h2>
<pre class="brush:clojure">
(try
  (println "Going to throw ...")
  (throw (Exception. "Testing error catching"))
  (println "Should not print, an Exception is thrown before")
  (catch Exception e
    (println "Oops ... an error ocurred.")
    (.printStackTrace e))
  (finally
    (println "Cleaning up!")))
</pre>
<p>Of course you can throw any kind of exception you want. For example, in checking function arguments:
</p>
<pre class="brush:clojure">
(import '(java.awt Rectangle))

(defn area [#^Rectangle r]
  (if (not (instance? Rectangle r))
    (throw (IllegalArgumentException. "Can only compute the area of a Rectangle.")))
  (* (.width r) (.height r)))
</pre>
<p>Above, despite the type declaration, one can pass any value to the <i>area</i> function and it will still work, but of course our class check will cut execution:
</p>
<pre>user=&gt; (area 10)                          
java.lang.IllegalArgumentException: Can only compute the area of a Rectangle. (NO_SOURCE_FILE:0)

user=&gt; (area (Rectangle. 0 0 10 10))
100
</pre>
<p><br />
</p>
<h2><span class="mw-headline" id="Executing_a_command_in_a_shell_and_capturing_its_output">Executing a command in a shell and capturing its output</span></h2>
<p>First we define the macro <i>exec</i>:
</p>
<pre class="brush:clojure">
(import '(java.io BufferedReader InputStreamReader))

(defmacro exec
  "Execute a command on the shell, passing to the given function
   the lazy sequence of lines read as output, and the rest of arguments."
  [cmd pred &amp; args]
  `(with-open [br# (BufferedReader. (InputStreamReader. (.getInputStream (.exec (Runtime/getRuntime) ~cmd))))]
    (~pred (line-seq br#) ~@args)))
</pre>
<p>Some explanations on the above macro syntax (see also <a rel="nofollow" class="external text" href="http://clojure.org/macros">clojure's macro syntax page</a>):
</p>
<ul><li> The backquote ` quotes the next expression, as defined by: `( &lt;any code here&gt; ). Which means the code block is <b>not</b> evaluated. But, unlike simple quote ', the backquote enables evaluation of expressions within the block when tagged with a ~ (a tilde).</li>
<li> The ~ (tilde) evaluates the immediate expression. Can only be used in the context of a backquoted code block.</li>
<li> The ~@ means <i>evaluate and expand</i>, which has the efect of placing the elements of a list as if they where declared in the code, without the list enclosure. So: `(~@(str "this" "that")) results in: "thisthat". In the example above, we expand the <i>&amp; args</i>, which is a list containing all arguments given to the exec macro beyond the first and second (which are bound to <i>cmd</i> and <i>pred</i>, respectively). In this way, we lay down the proper function call of the <i>pred</i>, which is expected to be a function name (a predicate); the reason we use ~ on it is to evaluate <i>pred</i> so that it renders the pointer to the function itself. That <i>pred</i> function, by design, must accept a lazy sequence of text lines and any number of arguments afterwards.</li>
<li> The # tagged at the end of a name expands to (gensym name), which results in creating a uniquely named symbol, to avoid name collisions.</li>
<li> Any code present outside the backquote (none, in the case above) will be executed at macro read time, not at code execution time (aka run time)! So any precomputations are possible before laying down the code that will be executed at run time.</li></ul>
<p><br />
Then we give the macro a command to execute and a function to process its stdout output.
</p>
<pre class="brush:clojure">
; List all files in the home directory:
(exec "ls /home/albert/"
      #(doseq [line&#160;%1] (println line)))
</pre>
<p>A second example, printing the file size of each listed file in the home directory:
</p>
<pre class="brush:clojure">
; Print the size of each file in the home directory:
(import '(java.io File))

(let [dir "/home/albert/"]
  (exec (str "ls " dir)
        #(doseq [line&#160;%1]
          (println (.length (File. (str dir line)))))))
</pre>
<p>A third example, telling the music player XMMS2 to jump to a specific track in its playlist:
</p>
<pre class="brush:clojure">
(let [track-number 125]
  (exec (str "xmms2 jump " track-number)
        (fn [lines] lines)))
</pre>
<p>The above is an extract from a clojure GUI for XMMS2, available at github <a rel="nofollow" class="external text" href="https://github.com/acardona/xmms2-clj/">xmms2-gui</a>.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Creating_a_derivative_of_a_function">Creating a derivative of a function</span></h2>
<p>The derivative of a function:
</p><p><img class="mwe-math-fallback-image-inline tex" alt="&#10;D f(x) = f&#39;(x) = \lim_{dx\rightarrow 0}\frac{f(x + dx) - f(x)}{dx}&#10;" src="_images/math/1/4/8/148bb03873bf084eb2654eb6d0da14d1.png" />
</p><p>We can approximate the derivative by choosing an arbitrarily precise value of the increment <i>dx</i>.
</p><p>So first we define a function that takes any function as argument and returns a new function that implements its derivative. For convenience, we define it within a closure that specifies the arbitrarily precise increment <i>dx</i> (but we could just pass it as argument):
</p>
<pre class="brush:clojure">
(let [dx (double 0.0001)]
  (defn derivative [f]
     "Return a function that is the derivative of the given function f, using dx increments."
     (fn [x]
        (/ (- (f (+ (double x) dx))
              (f x))
            dx))))
</pre>
<p>Then, for any example function like the cube of x:
</p>
<pre class="brush:clojure">
(defn cubic [x]
  (let [a (double x)]
    (* a a a)))
</pre>
<p>... we create its derivative function, which we place into a variable (note we use <i>def</i> and not <i>defn</i>):
</p>
<pre class="brush:clojure">
(def cubic-prime (derivative cubic))
</pre>
<p>We can now call the cubic-prime function simply like any other function:
</p>
<pre>(cubic-prime 2) 
-&gt; 12.000600010022566

(cubic-prime 3) 
-&gt; 27.00090001006572
 
(cubic-prime 4) 
-&gt; 48.00120000993502
</pre>
<p><br />
The derivative of x^3 is 3 * x^2, which for an x of 4 equals 48. Our derivative is as precise as low is the value of the increment <i>dx</i>.
</p><p>The above code translated from lisp code at <a rel="nofollow" class="external text" href="http://funcall.blogspot.com/2009/03/not-lisp-again.html">funcall blog</a>. Thanks <a rel="nofollow" class="external text" href="http://www.blogger.com/profile/03233353484280456977">Joe Marshall</a> for sharing this perl.
</p>
<h2><span class="mw-headline" id="Pretty_printing_a_primitive_array">Pretty printing a primitive array</span></h2>
<p>Suppose we create a primitive array of length 10:
</p>
<pre class="brush:clojure">
user=&gt; (def pa (make-array Integer/TYPE 10))
</pre>
<p>If we print it, we get:
</p>
<pre class="brush:clojure">
user=&gt; (println pa)
#&lt;int[] [I@169bc15&gt;
</pre>
<p>... which is not very useful. Instead, let's pretty print it.
</p><p>First, import the function <i>pprint</i> (and many other functions) from clojure-contrib pprint namespace:
</p>
<pre class="brush:clojure">
user=&gt; (use 'clojure.contrib.pprint)
</pre>
<p>Then, use it:
</p>
<pre class="brush:clojure">
user=&gt; (pprint pa)
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</pre>
<p><br />
A similar result can be obtained by wrapping primitive arrays with <i>seq</i>, which generates a Collection view on the primitive array:
</p>
<pre class="brush:clojure">
user=&gt; (println (seq pa))
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</pre>
<p>That <i>seq</i> creates only a view (and not a copy), you can convince yourself: changing the array changes the view, too:
</p>
<pre class="brush:clojure">
user=&gt; (def sa (seq pa))
user=&gt; sa
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
user=&gt; (aset pa 3 7)
user=&gt; (pprint pa)
[0, 0, 0, 7, 0, 0, 0, 0, 0, 0]
user=&gt; sa
[0, 0, 0, 7, 0, 0, 0, 0, 0, 0]
</pre>
<h2><span class="mw-headline" id="Loading_an_image_file_into_a_byte_array">Loading an image file into a byte array</span></h2>
<pre class="brush:clojure">
(import [java.io File FileInputStream]
(defn ^bytes load-file
  "Load a file into a byte array."
  [filepath]
  (let [^File f (File. filepath)
        len (int (.length f))
        ^bytes b (byte-array len)]
    (with-open [^FileInputStream fis (FileInputStream. f)]
      (loop [offset (int 0)]
        (if (&lt; offset len)
          (recur (unchecked-add offset (.read fis b offset (unchecked-subtract len offset)))))))
     b))
</pre>
<p>... which then may be parsed as a java.awt.Image:
</p>
<pre class="brush:clojure">
(def img (javax.imageioImageIO/read
               (java.io.ByteArrayInputStream.
                 (load-file "/home/acardona/Desktop/t2/NileBend.jpg"))))
</pre>
<p><br />
... which then may be shown as an ImagePlus:
</p>
<pre class="brush:clojure">
(.show (ij.ImagePlus. "nile bend" img))
</pre>

<!-- 
NewPP limit report
Cached time: 20200713064848
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.140 seconds
Real time usage: 0.144 seconds
Preprocessor visited node count: 3161/1000000
Preprocessor generated node count: 10226/1000000
Postâ€expand include size: 22967/2097152 bytes
Template argument size: 8333/2097152 bytes
Highest expansion depth: 8/40
Expensive parser function count: 0/3
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%   84.678      1 - -total
 56.35%   47.714      4 - Template:Key
 48.46%   41.034      4 - Template:Key_press/core
 17.69%   14.978      1 - Template:Learn
 15.56%   13.173      1 - Template:Menu
 13.87%   11.745      4 - Template:Submenu
  8.06%    6.827      3 - Template:Bc
  7.07%    5.989     39 - Template:MenuItem
  5.12%    4.332      7 - Template:GitHub
  4.13%    3.496      1 - Template:ImportingClasses
-->
</div><div class="printfooter">
Retrieved from "<a dir="ltr" href="index.php?title=Clojure_Scripting&amp;oldid=41219">http://imagej.net/index.php?title=Clojure_Scripting&amp;oldid=41219</a>"</div>
							</div>

			<div id="footer">
				<p> This page was last modified on 24 January 2020, at 11:54.</p><ul><li><a href="./ImageJ:Privacy_policy" title="ImageJ:Privacy policy">Privacy policy</a></li><li><a href="./ImageJ:About" class="mw-redirect" title="ImageJ:About">About ImageJ</a></li><li><a href="Imprint" title="Imprint">Imprint</a></li></ul>			</div>

			<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="./Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="./Category:Scripting" title="Category:Scripting">Scripting</a></li></ul></div></div>		</div>

		<div id="bottom-wrap">
			<div id="footer-wrap-inner">
				<div id="ternary" class="footer">
					<ul>
						<li class="widget">
							<img id="logo" src="skins/imagej-128.png" alt="">
						</li>
					</ul>
				</div>
			</div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.loader.load(["ext.fancytree","ext.suckerfish","mediawiki.toc","mediawiki.action.view.postEdit","site","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.SimpleTooltip"]);});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":295});});</script>
		</body>
		</html>
		